/* ----- 윈도우 개발 히스토리 ----- */

/* Windows API */

// 마이크로소프트 윈도우 운영체제에서 사용하는 API 이며, 윈도우 개발의 원조이다. Windows 3.1 의 탄생부터 함께했기 때문에 C 언어로되어 있다.
// 동적 링크 라이브러리( DLL ) 방식을 사용하며 OS 제어, GUI, 그래픽, 멀티미디어 등을 제어할 수 있다.

/*
운영체제가 크게 변경될 때마다 번전이 변경되었으며 크게 다음과 같이 발전했다.

Win16 : 16비트 버전 윈도우로 Windows 3.1 개발에 사용된다.
Win32 : 32비트 버전 윈도우로 Windows 95 부터 사용된다.
Win32s : subset 의 약자로 Win32 의 일부 기능이란 의미이다.
	=> 일부 16비트 윈도우에서 Win32 를 사용하기 위해 만들어 졌다.
Win32 for 64bit : 64용 이지만 새로운 API 를 추가하진 않았다.
	=> 운영체제 내부에 가상의 레이어( WOW64 )를 만들어 32비트 프로그램을 64비트 운영체제에서도 실행할 수 있도록 만들어졌다.

따라서, 가장 최신 API 는 Win32 라보 볼 수 있다.
*/

/* MFC( Microsoft Foundation Class Library ) */

// Window API 가 C 로 되어 있어서 이를 조금 더 편리하게 사용하기 위해 C++ 로 래핑( Wrapping )한 API를 말한다.
// 비주얼 편집기, 다양한 템플릿, 나름 스마트포인터 등의 당시엔 획기적인 기능들을 가지고 있으며, Visual Studio 에 기본 내장되어 있어서 많이 사용하던 기능이다.
// 하지만 Microsoft 조차 출시 후 MFC 가 사용하기 어려우니 Visual Basic 을 사용하라고 권장할 정도로 매우 복잡하다.
// C++ 표준에서 벗어난 함수들을 Microsort 스타일로 사용했기 때문에 결국 2014년 공식적으로 향후 지원을 중단했다.

/* Windows Template Library */

// 마이크로소프트 내부에서 사용하기 위해 별도의 라이브러리를 만들어서 사용하였는데 Win32 와 대응되는 코드가 많아서 인기가 좋았다고 한다.
// 점점 입소문이 나면서 오픈소스로 풀려서 지금도 업데이트 되고 있다.

/* Windows Form */

// 마이크로소프트에서 야심차게 통합 플랫폼 .NET 을 발표하면서 제공된 API 이다.널리 사용할 수 있도록 오픈소스로 제공되었으며
// 기존의 MFC 를 대체할 수 있도록 만들어진 녀석이다. 하지만 2014년에 공식 지원이 중단되어 버그 수정만 이뤄지게 되었고,
// 크로스-플랫폼 구현의 내부 용도로만 사용된다.

/* Windows Presentation Platform */

// 최초로 운영체제에서 하드웨어 가속을 지원하기 위해 개발된 API이다.
// 확대해도 안깨지는 벡터 그래픽, 폰트에 디자인을 수행할 수 있는 타이포그래피, 애니메이션 등 그래픽에 특화된 API로
// 내부에서는 DirectX 를 사용해 하드웨어 가속을 지원한다.
// 그런데 게임 개발자들 사이에서는 평가가 애매하였다. 하드웨어 가속을 위해서는 DirectX 를 사용하는 것이 이득이고,
// 일반 애플리케이션을 만들기 위해서는 복잡했기 때문이다.

/* Windows RT( Runtime ) */

// Windows 8 과 함께 발표된 새로운 크로스-플랫폼 API이다.
// 윈도우폰과 같은 모바일에 대응하기 위해 만들어졌으며 모든 구조가 순순한 C++ 이라 속도가 빠르다.
// 나름 신경써서 만든 녀석이지만 마이크로소프트의 애플화 계획이 무산되면서 끝날 줄로만 알았다.

/* UWP( Universal Windows Platform ) */

// Windows 10 과 함께 발표된 API 로 WinRT 의 개선판으로 윈도우 10 모바일, Xbox, PC 를 통합하려는 야심찬 계획으로 출발했다.
// 최근 XBOX 차세대기와 PC 의 통합 행보가 더욱 강화되면서 어쩔 수 없이 UWP 를 다뤄야할 날이 올지도 모르겠다.

/* ----- 메시지와 이벤트 ----- */

// 3단계인 윈도우 메시지 처리를 알아 보기 전에 윈도우 OS 의 작동원리를 알아보자.

/*
윈도우는 여러 개의 응용프로그램들이 한꺼번에 실행된다. 이런 멀티테스킹 환경을 위해 개발한 것이 이벤트 메시지 시스템이다.

[키보드] -> [입력 큐] -> [운영체제 윈도우 관리자] -> [실행중인 응용 프로그램 A] { 메시지 큐 -> 이벤트 핸들러 }
[마우스] ->										  -> [실행중인 응용 프로그램 B] { 메시지 큐 -> 이벤트 핸들러 }
												  -> [실행중인 응용 프로그램 C] { 메시지 큐 -> 이벤트 핸들러 }

위와 같이 운영체제에서 조작에 필요한 정보들을 받아서 실행중인 응용프로그램에게 각각 메시지를 보내주고, 응용프로그램은 그 메시지를 받아와서
필요한 처리를 하는 방식이다.
이때 보내는 측에서 보면 메시지( Message )를 보낸다고 하며, 받는 측에서는 이벤트( Event )가 발생했다고 판단한다.

응용프로그램에 전달된 메시지를 처리할 때는 메인 루프와 메시지 처리를 통해서 실행된다.

	[Event Queue]				[Main Loop]												[Window Procedure]
1. A 키를 눌렀다.			GetMessage()->TranslateMessage()->DispatchMessage()		처리 -> 메시지 처리
2. 윈도 사이즈가 바뀌었다.
3. ...

위와 같이 메인루프는 이벤트가 있으면 GetMessage 를 통해 메시지를 가져온다. 그리고 TranslateMessage 로 가져온 메시지를 처리하기
쉽게 변환한다. DispatchMessage 로 해당 메시지를 윈도 생성시 등록한 위도 프로시저에 넘겨준다.
*/

// 이런 윈도우 내부의 처리를 살펴 볼 수 있는 것이 Spy++ 이라는 도구이다.
// 도구 -> Spy++ 을 실행해 보면 운영체제가 어떻게 윈도우를 핸들로 관리하는가, 어떤 메시지가 전송되는가를 살펴볼 수 있다.