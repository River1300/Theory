/* ----- < 구조체 메모리 정렬 문제 > ----- */

//#include <iostream>
//struct OneByte
//{
//	char myChar;	// char TYPE : 1 BYTE
//};
//#pragma pack(push, 1)
//struct FiveByte	// #. 생각하기로는 5 BYTE를 차지하는 것이 정상이지만 8 BYTE를 차지한다.
//{
//	char myChar;	// char TYPE : 1 BYTE
//	int myInt;		// int TYPE : 4 BYTE
////		=> 컴파일러가 효율적으로 메모리를 관리하기 위해 구조체 멤버들의 크기를 조절
////		=> myChar 1 BYTE, 3 BYTE Padding, myInt 4 BYTE
////		=> 4바이트 단위로 주소를 관리하면 편하기 때문에 1바이트 뒤에 3바이트의 패딩을 추가한다.
////		=> 그래서 구조체의 실제 크기는 8바이트가 된다.
//};
//#pragma pack(pop)
////	=> 구조체의 바이트를 관리하는 pack(), 1 바이트 단위로 패킹
//int main()
//{
//	std::cout << sizeof(OneByte) << '\n';
//	std::cout << sizeof(FiveByte) << '\n';
//}

/* ----- < 울타리 말뚝 오류 > ----- */

// Off-By-One Error (OBOE), Off-By-One Bug(OBOB), OB1 Error
// 경계선 문제로 발생하는 것으로, 배열과 같이 크기가 정해져 있는 자료 구조에 허용값을 하나 넘어가는 경우를 일컫는 오류이다.

/* 반복문의 조건에서 부등호 실수 */

/*
for(index = 0; index < 5; index++)
{	0 ~ 4까지 5번 반복한다. 만약 5를 실행시키고자 한다면 index <= 5라고 명시해야 한다.
	loop statements
}
*/

/* 인덱스는 0에서 시작하는 것을 오해 */

// FencePost error, Telegraph pole, Lamp-post, Picket Fence Error등 다양한 이름이 있는데 모두 말뚝과 관련된 표현이다.
// 10미터의 울타리가 있는데, 여기에 2미터 간격으로 말뚝을 설치하려면 몇 개가 필요하나? 10 / 2 = 5 라고 생각하기 쉬운데 틀렸다.
// 시작은 0 부터 시작하기 때문에 0 지점에 1개 ~ 2, 4, 6, 8, 10 총 6개가 필요하다.
// N개의 배열은 인덱스 0에서 시작하므로 N - 1이 가장 마지막 값이다.

/* ----- < 컴파일과 링크 > ----- */

/* 헤더파일과 소스파일 */

// c++ 언어는 선언과 정의로 구분되어 있다. 많은 양의 코드를 입력하게 되며, 효율적으로 작성하기 위해 반복되는 작업들을 따로 묶어서 선언하는 경우가 많다.
// 또한 다른 사람이 만들어 둔 편리한 기능들을 가져다 사용할 경우도 있다. 그래서 선언과 정의를 다음과 같이 개별 파일로 묶어 둔다.

// 헤더( header )파일 : .h, .hxx, .hpp, 함수나 변수의 선언을 모아둔 파일, 어떠한 기능이 있는지, 어떤 규격( 매개변수, 이름, 반환값 등 )인지 알려주는 용도
// 소스( source )파일 : .cpp, .c, .cxx, 함수나 변수의 정의를 모아둔 파일, 실제로 기능을 구현하는 곳
// 라이브러리( library )파일 : .lib, .dll, 소스파일을 코드가 아닌 컴파일된 기계어로 제공하는 파일, 주로 자신이 만든 기능을 배포하거나, 프레임워크 처럼 한 번 만들고 자주 수정하지 않는 기능을 포함시킬 때 사용

/* #inclue 지시자( Directive ) */

/*
#pragma once

int Square(int x);
*/

// Square 함수에 대한 선언, 헤더는 크게 사용자가 만든 헤더와 시스템 헤더로 구분된다.
// 시스템 헤더 : c++ 언어 및 Standard Library에서 기본적으로 제공하는 기능들
// 사용자 헤더 : 프로그래머가 직접 만든 헤더

// 첫번째 전처리기 지시자인 #pragma once는 단 한 번만 선언하라는 의미
//		=> #include를 사용하여 MyHeader.h를 여러 소스파일에서 포함시킬 수 있는데, 이럴 경우 중복 선언 에러가 발생할 수 있다.
//		=> 따라서 중복선언을 피하기 위해 #pragma once를 명시해줘야 한다.

/*
#include "MyHeader.h"

int Square(int x)
{
	return x * x;
}	
*/

// #include < ... > : 시스템 헤더 파일을 포함
// #include " ... " : 사용자 헤더 파일을 포함( 현재 소스가 있는 디렉토리, 현재 헤더가 있는 디렉토리, 시스템에 정의되어 있는 디렉토리 )

/* 컴파일과 링크 */

// 기본적으로 헤더 파일은 컴파일에 사용되지 않는다. 대신 소스파일의 전처리기 지시자 #include를 통해 소스 파일에 포함된다.
// 전처리기( Pre-Processor )라고 부르는 이유가 바로 컴파일 이전 단계에 수행되어 소스파일을 수정하기 때문이다.

/*
즉, .cpp를 컴파일 할 때는 내부적으로 다음과 같이 된다.
int Square(int x);

int Square(int x)
{
	return x * x;
}
#include 지시자가 .h를 포함시키기 때문에 헤더파일의 내용이 해당 라인에 삽입되는 것
*/

/*
Main.cpp 역시 마찬가지

iostream 내용들 ...

int Square(int x);

int main()
{
	std::cout<<Square(2)<<std::endl;
	std::cout<<pow(2,2)<<std::endl;
}
주의할 것은 이 단계에서는 함수의 선언만 포함되며, 정의는 .cpp에 속해 있다.
*/

// 1. 빌드 -> 솔루션 정리 : 현재 프로젝트의 중간 파일들을 모두 청소
// 2. .cpp를 열고 빌드 -> 컴파일 : 컴파일 진행( Ctrl + F7 )
// 3. 마찬가지로 Main.cpp를 열고 빌드 -> 컴파일
//		=> 프로젝트 폴더에 Debug라는 폴더가 있고 해당 폴더를 열어보면 컴파일 결과물을 볼 수 있다.
// 컴파일러가 컴파일을 성곡하면 각각 .obj라는 목적어 파일( Object File )을 만들어 둔다.
//		=> 목적어 파일은 헤더 파일의 내용을 포함 시킨 후 다음 단계인 링크에 필요한 정보( 변수 및 함수의 선언+정의 정보 )를 미리 모아두는 것

// 만들어진 목적어 파일을 연동하여 실행파일을 만든 것이 링크

/* 정적 라이브러리( Static Library )와 동적 라이브러리( Dynamic-Link Library ) */

// 컴파일이 모두 끝난 .obj 파일들을 한 번에 묶어서 링크에 사용할 수 있도록 해 주는 것이 라이브러( Static Library )다.

/* 정적 라이브러리 */

// static 즉 변경할 수 없다는 의미
// 한 번 만들어진 라이브러리는 .lib 파일로 사용하는데 이렇게 한 번 만들어진 내부 기능은 변경할 수 있는 방법이 없다.
// 만약 버그 수정이나 기능 추가등으로 인해 내용을 변경해야 한다면 lib 파일을 재배포 하는 방법 밖에 없다.
// 정적 라이브러리는 보통 헤더파일( .h )과 라이브러리 파일( .lib )을 제공하며, 이를 각각 컴파일/링크 단계에 추가해 준다.
// 헤더는 당연히 우리의 소스 코드에 직접 #include 를 통해 지정해 준다.
// 라이브러리는 외부 종속성에 추가해 주는데, 비주얼 스튜디오에서는 프로젝트 옵션의 추가 종속성에 추가
//		=> 프로젝트 -> 속성 -> 링커 -> 입력 -> 추가 종속성 에 추가할 라이브러리 파일을 넣어 주면 된다.

/* 동적 라이브러리 */

// 정적 라이브러리는 내용이 변경되어 라이브러리 파일을 재배포해도 큰 문제가 있다.
//	=> 사용자가 해당 라이브러리를 갱신하기 위해서는 자신의 프로젝트를 다시 빌드해 줘야만 한다.
//		1. 게임의 치명적인 버그 발션
//		2. 디버그 해보니 외부 라이브러리의 버그로 새로운 버전으로 업데이트 필요
//		3. 새로운 라이브러리를 다운 받고 프로젝트 다시 빌드
//		4. 사용자에게 실행파일 재배포
// 위와 같은 흐름이되는데, 개발 프로세스에서 3번 이슈는 치명적
//		=> 상용 프로젝트는 빌드 한 번 하는데 몇 시간씩 걸린다. QA팀은 프로젝트가 빌드되면 전체 검수를 다시 해야 한다.
//		=> 사용자에게 재배포해야 하는 이슈도 크다.

// 이런 문제를 해결하기 위한 것이 실행 시간에 링크가 가능한 동적라이브러리( .dll )
// 링크 과정에서 간단한 정보만을 남겨 놓고, 실행 시간에 그 정보를 이용해 기능을 링크 하는 방식을 사용한다.
//		=> 라이브러리의 기능이 변경되어도 다시 빌드할 필요 없이 간단히 라이브러리만 배포하면 된다.

// 동적 라이브러리는 헤더파일( .h )과 라이브러리파일( .lib ) 그리고 동적라이브러리 파일( .lib )을 제공한다.
// 동적 라이브러리의 .lib 는 정적 라이브러리의 그것과는 달리 내부에 함수 본체와 같은 상세 정보는 없고 오직 정보만을 기록하고 있다.
//		=> 함수 본체는 dll에 들어 있다.

/*
정적 라이브러리					동적 라이브러리
lib 파일						dll 파일
실행 파일만으로 실행			실행파일과 별도의 dll을 이용하여 실행
외부 정보를 참조하지 않기 떄문	실행 시간에 DLL 파일을 뒤져야 하므로
에 빠르다.						느리다.
라이브러리 기능을 수정하기가	라이브러리를 쉽게 업그레이드 가능
어렵다.							하다.
서로 다른 프로젝트에서 사용하	서로 다른 프로젝트에서도 하나의
려면 각각 라이브러리를 링크해	DLL만 있으면 사용이 가능하다.
야만 한다.						
*/

/* ----- < 스택( Stack )과 큐( Queue ) > ----- */

// 컴퓨터는 기본적으로 입력을 받아 계산하고 출력하는 것
//	=> 자료를 입력/출력으로 전달할 때나 계산에 사용할 때의 정보가 매우 중요
//	=> 기본 형인 정수만 사용해서는 표현 범위가 제한 되기 때문에 다양한 방식을 사용하는데 이러한 것을 자료 구조( Data Structure )라 부름

// 이러한 자료 구조 중 가장 기본적이면서 하드웨어, 소프트웨어 구조 모두에서 사용되는 것이 스택과 큐이다.

/* 스택( Stack ) : LIFO - Last In First Out */

// 사전적으로 쌓는다는 의미
// 책을 쌓게 되면, 순서대로 위에서 부터 하나씩 꺼내야 한다. 가장 바닥에 놓인 책을 뽑는 것은 안된다.
// 이러한 특성을 후입선출 또는 Last In First Out, LIFO라 한다.

/*
입력 : Push, 가장 꼭대기에 데이터를 집어 넣음
출력 : Pop, 가장 꼭대기의 데이터를 가져옴

스택은 가장 최근 작업이 중요한 경우에 주로 사용된다. 대표적으로 함수 호출 관리에 스택을 사용한다.
*/

/* 큐( Queue ) : FIFO - First In First Out */

// 사전적으로 줄을 서다라는 의미
// 가장 먼저 온 손님은 그 만큼 오래 기다렸기 때문에 가장 먼저 처리해 줘야 하는 것

/*
입력 : Push, 가장 뒤에 데이터를 집어 넣음
출력 : Pop, 가장 앞의 데이터를 가져옴

큐는 여러 개 실행되는 작업을 순차적으로 처리할 때 사용, 대표적으로 윈도우 메시지 처리 및 프로세스 관리에 사용
*/

/* Overflow & Underflow */

// 컴퓨터 메모리 공간은 한정적이기 때문에 자료 구조들은 한계치가 존재한다.
// Overflow : 준비된 공간을 넘쳐서 데이터를 집어 넣을 때 발생
// Underflow : 준비된 공간에 아무런 값이 없는데, 값을 가져가려고 할 때 발생

/*
가장 유명한 Stack Overflow

void Infinite();

int main()
{
	Infinite();
}

void Infinite()
{
	Infinite();
}
이 프로그램을 실행하면 Stack Overflow 예외가 발생한다.
함수가 호출될 때마다 호출스택( Call Stack )에 함수의 정보를 쌓아 올리는 방식이므로 준비한 스택을 넘쳐 버리게 됨
*/

/* ----- < C/C++ 언어의 Compile 원리 > ----- */

// left <- right : 기본적으로 C++ 언어는 오른쪽에서 왼쪽으로 해석된다.
// a = b = 0 : b 에 먼저 0 을 대입한 후, a 에 b 를 대입하는 순서

// const int a : a is int which is constant( a는 정수이며 상수형 )
// int const a : a is constant int( a는 상수형 정수 )	=> 같은 의미

// const int * a : a is pointer to int which is constant( a 는 포인터로 정수를 가리키며 그 정수는 상수 )
// int * const b : b is constant pointer to int( b 는 상수 포인터로 정수를 가리킨다. )
// int const * c : c is pointer to constant int( c 는 상ㅇ수 정수를 가리키는 포인터 )

// *a = 1 : ERROR( a 가 가리키는 정수는 상수이므로 값을 변경할 수 없다. )
// a++ : OK( a 는 일반 포인터이므로 이동 가능 )
// *b = 1 : OK( b 는 일반 정수를 가리키므로 값을 변경할 수 있다. )
// b++ : ERROR( b 는 상수 포인터이므로 이동 불가능 )
// *c = 1 : ERROR( c 는 상수 정수를 가리키므로 값을 변경할 수 없다. )
// c++ : OK( c 는 일반 포인터이므로 이동 가능 )
// const int * 와 int const * 는 결국 같은 의미